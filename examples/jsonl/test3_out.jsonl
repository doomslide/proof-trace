{"syntheticName":"add_comm_goal_goal_4213051773522487389","sourceDecl":"add_comm","proof":"Eq.mpr (id (congrArg (fun _a => _a = b + 0) (Nat.zero_add b))) (Eq.refl b)","primitives":{"primitives":[{"value":"fun {α β} h b => ⋯ ▸ b","type":"{α β : Sort u} → α = β → β → α","name":"Eq.mpr","kind":"definition"},{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"type":"∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂","name":"congrArg","kind":"theorem"},{"value":"fun {α} a => a","type":"{α : Sort u} → α → α","name":"id","kind":"definition"},{"value":"fun n => { ofNat := n }","type":"(n : Nat) → OfNat Nat n","name":"instOfNatNat","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"∀ (n : Nat), 0 + n = n","name":"Nat.zero_add","kind":"theorem"},{"type":"∀ {α : Sort u} {a b : α}, a = b → b = a","name":"Eq.symm","kind":"theorem"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"value":"fun {α} {a} => Eq.refl a","type":"∀ {α : Sort u} {a : α}, a = a","name":"rfl","kind":"definition"},{"type":"Type u → Nat → Type u","name":"OfNat","kind":"inductive","ctors":[{"type":"{α : Type u} → {x : Nat} → α → OfNat α x","name":"OfNat.mk"}]}]},"prettyProof":"Eq.mpr (id (congrArg (fun _a => _a = b + 0) (Nat.zero_add b))) (Eq.refl b)","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"0 + b = b + 0","distractors":[],"context":["(b : Nat)"]}
{"syntheticName":"add_comm_goal_goal_9947580324073970741","sourceDecl":"add_comm","proof":"Eq.refl (b + n).succ","primitives":{"primitives":[{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]}]},"prettyProof":"Eq.refl (b + n).succ","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"(b + n).succ = (b + n).succ","distractors":[],"context":["(b : Nat)","(n : Nat)","(IH : n + b = b + n)"]}
{"syntheticName":"add_comm_goal_goal_4744990405743397177","sourceDecl":"add_comm","proof":"Nat.rec (Eq.mpr (id (congrArg (fun _a => _a = b + 0) (Nat.zero_add b))) (Eq.refl b))\n  (fun n IH =>\n    Eq.mpr (id (congrArg (fun _a => _a = b + (n + 1)) (Nat.succ_add n b)))\n      (Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n        (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ))))\n  a","primitives":{"primitives":[{"value":"fun {α β} h b => ⋯ ▸ b","type":"{α β : Sort u} → α = β → β → α","name":"Eq.mpr","kind":"definition"},{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"type":"∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂","name":"congrArg","kind":"theorem"},{"value":"fun {α} a => a","type":"{α : Sort u} → α → α","name":"id","kind":"definition"},{"value":"fun n => { ofNat := n }","type":"(n : Nat) → OfNat Nat n","name":"instOfNatNat","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"∀ (n m : Nat), n + m.succ = (n + m).succ","name":"Nat.add_succ","kind":"theorem"},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"∀ (n : Nat), 0 + n = n","name":"Nat.zero_add","kind":"theorem"},{"type":"∀ (n m : Nat), n.succ + m = (n + m).succ","name":"Nat.succ_add","kind":"theorem"},{"type":"∀ {α : Sort u} {a b : α}, a = b → b = a","name":"Eq.symm","kind":"theorem"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"value":"fun {α} {a} => Eq.refl a","type":"∀ {α : Sort u} {a : α}, a = a","name":"rfl","kind":"definition"},{"type":"Type u → Nat → Type u","name":"OfNat","kind":"inductive","ctors":[{"type":"{α : Type u} → {x : Nat} → α → OfNat α x","name":"OfNat.mk"}]}]},"prettyProof":"Nat.rec (Eq.mpr (id (congrArg (fun _a => _a = b + 0) (Nat.zero_add b))) (Eq.refl b))\n  (fun n IH =>\n    Eq.mpr (id (congrArg (fun _a => _a = b + (n + 1)) (Nat.succ_add n b)))\n      (Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n        (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ))))\n  a","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"a + b = b + a","distractors":[],"context":["(a : Nat)","(b : Nat)"]}
{"syntheticName":"add_comm_goal_goal_16978801500470703264","sourceDecl":"add_comm","proof":"Eq.mpr (id (congrArg (fun _a => _a = b + (n + 1)) (Nat.succ_add n b)))\n  (Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n    (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ)))","primitives":{"primitives":[{"value":"fun {α β} h b => ⋯ ▸ b","type":"{α β : Sort u} → α = β → β → α","name":"Eq.mpr","kind":"definition"},{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"type":"∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂","name":"congrArg","kind":"theorem"},{"value":"fun {α} a => a","type":"{α : Sort u} → α → α","name":"id","kind":"definition"},{"value":"fun n => { ofNat := n }","type":"(n : Nat) → OfNat Nat n","name":"instOfNatNat","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"∀ (n m : Nat), n + m.succ = (n + m).succ","name":"Nat.add_succ","kind":"theorem"},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"∀ (n m : Nat), n.succ + m = (n + m).succ","name":"Nat.succ_add","kind":"theorem"},{"type":"∀ {α : Sort u} {a b : α}, a = b → b = a","name":"Eq.symm","kind":"theorem"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"value":"fun {α} {a} => Eq.refl a","type":"∀ {α : Sort u} {a : α}, a = a","name":"rfl","kind":"definition"},{"type":"Type u → Nat → Type u","name":"OfNat","kind":"inductive","ctors":[{"type":"{α : Type u} → {x : Nat} → α → OfNat α x","name":"OfNat.mk"}]}]},"prettyProof":"Eq.mpr (id (congrArg (fun _a => _a = b + (n + 1)) (Nat.succ_add n b)))\n  (Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n    (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ)))","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"n + 1 + b = b + (n + 1)","distractors":[],"context":["(b : Nat)","(n : Nat)","(IH : n + b = b + n)"]}
{"syntheticName":"add_comm_goal_goal_2059227287204420360","sourceDecl":"add_comm","proof":"Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ)","primitives":{"primitives":[{"value":"fun {α β} h b => ⋯ ▸ b","type":"{α β : Sort u} → α = β → β → α","name":"Eq.mpr","kind":"definition"},{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"type":"∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂","name":"congrArg","kind":"theorem"},{"value":"fun {α} a => a","type":"{α : Sort u} → α → α","name":"id","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"∀ {α : Sort u} {a b : α}, a = b → b = a","name":"Eq.symm","kind":"theorem"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"value":"fun {α} {a} => Eq.refl a","type":"∀ {α : Sort u} {a : α}, a = a","name":"rfl","kind":"definition"}]},"prettyProof":"Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ)","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"(n + b).succ = (b + n).succ","distractors":[],"context":["(b : Nat)","(n : Nat)","(IH : n + b = b + n)"]}
{"syntheticName":"add_comm_goal_goal_8337732176543814311","sourceDecl":"add_comm","proof":"Eq.refl b","primitives":{"primitives":[{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"value":"fun n => { ofNat := n }","type":"(n : Nat) → OfNat Nat n","name":"instOfNatNat","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"type":"Type u → Nat → Type u","name":"OfNat","kind":"inductive","ctors":[{"type":"{α : Type u} → {x : Nat} → α → OfNat α x","name":"OfNat.mk"}]}]},"prettyProof":"Eq.refl b","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"b = b + 0","distractors":[],"context":["(b : Nat)"]}
{"syntheticName":"add_comm_goal_goal_18371717491783982669","sourceDecl":"add_comm","proof":"Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n  (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ))","primitives":{"primitives":[{"value":"fun {α β} h b => ⋯ ▸ b","type":"{α β : Sort u} → α = β → β → α","name":"Eq.mpr","kind":"definition"},{"value":"fun α => α","type":"Sort u → Sort u","name":"outParam","kind":"definition"},{"type":"∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂","name":"congrArg","kind":"theorem"},{"value":"fun {α} a => a","type":"{α : Sort u} → α → α","name":"id","kind":"definition"},{"value":"fun n => { ofNat := n }","type":"(n : Nat) → OfNat Nat n","name":"instOfNatNat","kind":"definition"},{"value":"fun {α} [Add α] => { hAdd := fun a b => Add.add a b }","type":"{α : Type u_1} → [Add α] → HAdd α α α","name":"instHAdd","kind":"definition"},{"type":"Sort u → Sort v → Sort (max (max 1 u) v)","name":"PProd","kind":"inductive","ctors":[{"type":"{α : Sort u} → {β : Sort v} → α → β → α ×' β","name":"PProd.mk"}]},{"type":"Type u → Type v → outParam (Type w) → Type (max (max u v) w)","name":"HAdd","kind":"inductive","ctors":[{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ","name":"HAdd.mk"}]},{"type":"Sort u","name":"PUnit","kind":"inductive","ctors":[{"type":"PUnit","name":"PUnit.unit"}]},{"type":"∀ (n m : Nat), n + m.succ = (n + m).succ","name":"Nat.add_succ","kind":"theorem"},{"type":"Type","name":"Nat","kind":"inductive","ctors":[{"type":"Nat","name":"Nat.zero"},{"type":"Nat → Nat","name":"Nat.succ"}]},{"value":"{ add := Nat.add }","type":"Add Nat","name":"instAddNat","kind":"definition"},{"type":"∀ {α : Sort u} {a b : α}, a = b → b = a","name":"Eq.symm","kind":"theorem"},{"type":"{α : Sort u_1} → α → α → Prop","name":"Eq","kind":"inductive","ctors":[{"type":"∀ {α : Sort u_1} (a : α), a = a","name":"Eq.refl"}]},{"value":"fun x x_1 =>\n  Nat.brecOn (motive := fun x => Nat → Nat) x_1\n    (fun x f x_2 =>\n      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x => Nat → Nat) x → Nat) x_2, x with\n        | a, Nat.zero => fun x => a\n        | a, b.succ => fun x => (x.1 a).succ)\n        f)\n    x","type":"Nat → Nat → Nat","name":"Nat.add","kind":"definition"},{"type":"Type u → Type u","name":"Add","kind":"inductive","ctors":[{"type":"{α : Type u} → (α → α → α) → Add α","name":"Add.mk"}]},{"value":"fun {α} {a} => Eq.refl a","type":"∀ {α : Sort u} {a : α}, a = a","name":"rfl","kind":"definition"},{"type":"Type u → Nat → Type u","name":"OfNat","kind":"inductive","ctors":[{"type":"{α : Type u} → {x : Nat} → α → OfNat α x","name":"OfNat.mk"}]}]},"prettyProof":"Eq.mpr (id (congrArg (fun _a => (n + b).succ = _a) (Nat.add_succ b n)))\n  (Eq.mpr (id (congrArg (fun _a => _a.succ = (b + n).succ) IH)) (Eq.refl (b + n).succ))","originalSource":"[source extraction not implemented]","mathlibVersion":"unknown (lake-manifest.json not found)","leanVersion":"4.20.0-rc2","goal":"(n + b).succ = b + (n + 1)","distractors":[],"context":["(b : Nat)","(n : Nat)","(IH : n + b = b + n)"]}
